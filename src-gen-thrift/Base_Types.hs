{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.2)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Base_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data Status = On|Off  deriving (P.Show,P.Eq, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum Status where
  fromEnum t = case t of
    On -> 1
    Off -> 2
  toEnum t = case t of
    1 -> On
    2 -> Off
    _ -> X.throw T.ThriftException
instance H.Hashable Status where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary Status where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data TestMessage = TestMessage  { testMessage_m1 :: (Map.HashMap LT.Text I.Int32)
  , testMessage_m2 :: (Map.HashMap DemoMessage DemoMessage)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable TestMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` testMessage_m1 record   `H.hashWithSalt` testMessage_m2 record  
instance QC.Arbitrary TestMessage where 
  arbitrary = M.liftM TestMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TestMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TestMessage{testMessage_m1 = testMessage_m1 obj} then P.Nothing else P.Just $ default_TestMessage{testMessage_m1 = testMessage_m1 obj}
    , if obj == default_TestMessage{testMessage_m2 = testMessage_m2 obj} then P.Nothing else P.Just $ default_TestMessage{testMessage_m2 = testMessage_m2 obj}
    ]
from_TestMessage :: TestMessage -> T.ThriftVal
from_TestMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("m1",T.TMap T.T_STRING T.T_I32 $ P.map (\(_k3,_v4) -> (T.TString $ E.encodeUtf8 _k3, T.TI32 _v4)) $ Map.toList _v2))) $ testMessage_m1 record
  , (\_v2 -> P.Just (2, ("m2",T.TMap (T.T_STRUCT typemap_DemoMessage) (T.T_STRUCT typemap_DemoMessage) $ P.map (\(_k5,_v6) -> (from_DemoMessage _k5, from_DemoMessage _v6)) $ Map.toList _v2))) $ testMessage_m2 record
  ]
write_TestMessage :: (T.Protocol p, T.Transport t) => p t -> TestMessage -> P.IO ()
write_TestMessage oprot record = T.writeVal oprot $ from_TestMessage record
encode_TestMessage :: (T.Protocol p, T.Transport t) => p t -> TestMessage -> LBS.ByteString
encode_TestMessage oprot record = T.serializeVal oprot $ from_TestMessage record
to_TestMessage :: T.ThriftVal -> TestMessage
to_TestMessage (T.TStruct fields) = TestMessage{
  testMessage_m1 = P.maybe (testMessage_m1 default_TestMessage) (\(_,_val8) -> (case _val8 of {T.TMap _ _ _val9 -> (Map.fromList $ P.map (\(_k11,_v10) -> ((case _k11 of {T.TString _val12 -> E.decodeUtf8 _val12; _ -> P.error "wrong type"}),(case _v10 of {T.TI32 _val13 -> _val13; _ -> P.error "wrong type"}))) _val9); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  testMessage_m2 = P.maybe (testMessage_m2 default_TestMessage) (\(_,_val8) -> (case _val8 of {T.TMap _ _ _val14 -> (Map.fromList $ P.map (\(_k16,_v15) -> ((case _k16 of {T.TStruct _val17 -> (to_DemoMessage (T.TStruct _val17)); _ -> P.error "wrong type"}),(case _v15 of {T.TStruct _val18 -> (to_DemoMessage (T.TStruct _val18)); _ -> P.error "wrong type"}))) _val14); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TestMessage _ = P.error "not a struct"
read_TestMessage :: (T.Transport t, T.Protocol p) => p t -> P.IO TestMessage
read_TestMessage iprot = to_TestMessage <$> T.readVal iprot (T.T_STRUCT typemap_TestMessage)
decode_TestMessage :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TestMessage
decode_TestMessage iprot bs = to_TestMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_TestMessage) bs
typemap_TestMessage :: T.TypeMap
typemap_TestMessage = Map.fromList [(1,("m1",(T.T_MAP T.T_STRING T.T_I32))),(2,("m2",(T.T_MAP (T.T_STRUCT typemap_DemoMessage) (T.T_STRUCT typemap_DemoMessage))))]
default_TestMessage :: TestMessage
default_TestMessage = TestMessage{
  testMessage_m1 = Map.empty,
  testMessage_m2 = Map.empty}
data Test2Message = Test2Message  { test2Message_ms :: (Vector.Vector DemoMessage)
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Test2Message where
  hashWithSalt salt record = salt   `H.hashWithSalt` test2Message_ms record  
instance QC.Arbitrary Test2Message where 
  arbitrary = M.liftM Test2Message (QC.arbitrary)
  shrink obj | obj == default_Test2Message = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Test2Message{test2Message_ms = test2Message_ms obj} then P.Nothing else P.Just $ default_Test2Message{test2Message_ms = test2Message_ms obj}
    ]
from_Test2Message :: Test2Message -> T.ThriftVal
from_Test2Message record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v21 -> P.Just (1, ("ms",T.TList (T.T_STRUCT typemap_DemoMessage) $ P.map (\_v23 -> from_DemoMessage _v23) $ Vector.toList _v21))) $ test2Message_ms record
  ]
write_Test2Message :: (T.Protocol p, T.Transport t) => p t -> Test2Message -> P.IO ()
write_Test2Message oprot record = T.writeVal oprot $ from_Test2Message record
encode_Test2Message :: (T.Protocol p, T.Transport t) => p t -> Test2Message -> LBS.ByteString
encode_Test2Message oprot record = T.serializeVal oprot $ from_Test2Message record
to_Test2Message :: T.ThriftVal -> Test2Message
to_Test2Message (T.TStruct fields) = Test2Message{
  test2Message_ms = P.maybe (test2Message_ms default_Test2Message) (\(_,_val25) -> (case _val25 of {T.TList _ _val26 -> (Vector.fromList $ P.map (\_v27 -> (case _v27 of {T.TStruct _val28 -> (to_DemoMessage (T.TStruct _val28)); _ -> P.error "wrong type"})) _val26); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Test2Message _ = P.error "not a struct"
read_Test2Message :: (T.Transport t, T.Protocol p) => p t -> P.IO Test2Message
read_Test2Message iprot = to_Test2Message <$> T.readVal iprot (T.T_STRUCT typemap_Test2Message)
decode_Test2Message :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Test2Message
decode_Test2Message iprot bs = to_Test2Message $ T.deserializeVal iprot (T.T_STRUCT typemap_Test2Message) bs
typemap_Test2Message :: T.TypeMap
typemap_Test2Message = Map.fromList [(1,("ms",(T.T_LIST (T.T_STRUCT typemap_DemoMessage))))]
default_Test2Message :: Test2Message
default_Test2Message = Test2Message{
  test2Message_ms = Vector.empty}
data BaseMessage = BaseMessage  { baseMessage_str :: LT.Text
  , baseMessage_flag :: P.Bool
  , baseMessage_b :: I.Int8
  , baseMessage_int16 :: I.Int16
  , baseMessage_int32 :: I.Int32
  , baseMessage_int64 :: I.Int64
  , baseMessage_d :: P.Double
  , baseMessage_strs :: (Vector.Vector LT.Text)
  , baseMessage_mstrs :: (Map.HashMap LT.Text I.Int32)
  , baseMessage_sint :: (Set.HashSet I.Int32)
  , baseMessage_status :: Status
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable BaseMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` baseMessage_str record   `H.hashWithSalt` baseMessage_flag record   `H.hashWithSalt` baseMessage_b record   `H.hashWithSalt` baseMessage_int16 record   `H.hashWithSalt` baseMessage_int32 record   `H.hashWithSalt` baseMessage_int64 record   `H.hashWithSalt` baseMessage_d record   `H.hashWithSalt` baseMessage_strs record   `H.hashWithSalt` baseMessage_mstrs record   `H.hashWithSalt` baseMessage_sint record   `H.hashWithSalt` baseMessage_status record  
instance QC.Arbitrary BaseMessage where 
  arbitrary = M.liftM BaseMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BaseMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BaseMessage{baseMessage_str = baseMessage_str obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_str = baseMessage_str obj}
    , if obj == default_BaseMessage{baseMessage_flag = baseMessage_flag obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_flag = baseMessage_flag obj}
    , if obj == default_BaseMessage{baseMessage_b = baseMessage_b obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_b = baseMessage_b obj}
    , if obj == default_BaseMessage{baseMessage_int16 = baseMessage_int16 obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_int16 = baseMessage_int16 obj}
    , if obj == default_BaseMessage{baseMessage_int32 = baseMessage_int32 obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_int32 = baseMessage_int32 obj}
    , if obj == default_BaseMessage{baseMessage_int64 = baseMessage_int64 obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_int64 = baseMessage_int64 obj}
    , if obj == default_BaseMessage{baseMessage_d = baseMessage_d obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_d = baseMessage_d obj}
    , if obj == default_BaseMessage{baseMessage_strs = baseMessage_strs obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_strs = baseMessage_strs obj}
    , if obj == default_BaseMessage{baseMessage_mstrs = baseMessage_mstrs obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_mstrs = baseMessage_mstrs obj}
    , if obj == default_BaseMessage{baseMessage_sint = baseMessage_sint obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_sint = baseMessage_sint obj}
    , if obj == default_BaseMessage{baseMessage_status = baseMessage_status obj} then P.Nothing else P.Just $ default_BaseMessage{baseMessage_status = baseMessage_status obj}
    ]
from_BaseMessage :: BaseMessage -> T.ThriftVal
from_BaseMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v31 -> P.Just (1, ("str",T.TString $ E.encodeUtf8 _v31))) $ baseMessage_str record
  , (\_v31 -> P.Just (2, ("flag",T.TBool _v31))) $ baseMessage_flag record
  , (\_v31 -> P.Just (3, ("b",T.TByte _v31))) $ baseMessage_b record
  , (\_v31 -> P.Just (4, ("int16",T.TI16 _v31))) $ baseMessage_int16 record
  , (\_v31 -> P.Just (5, ("int32",T.TI32 _v31))) $ baseMessage_int32 record
  , (\_v31 -> P.Just (6, ("int64",T.TI64 _v31))) $ baseMessage_int64 record
  , (\_v31 -> P.Just (7, ("d",T.TDouble _v31))) $ baseMessage_d record
  , (\_v31 -> P.Just (8, ("strs",T.TList T.T_STRING $ P.map (\_v33 -> T.TString $ E.encodeUtf8 _v33) $ Vector.toList _v31))) $ baseMessage_strs record
  , (\_v31 -> P.Just (9, ("mstrs",T.TMap T.T_STRING T.T_I32 $ P.map (\(_k34,_v35) -> (T.TString $ E.encodeUtf8 _k34, T.TI32 _v35)) $ Map.toList _v31))) $ baseMessage_mstrs record
  , (\_v31 -> P.Just (10, ("sint",T.TSet T.T_I32 $ P.map (\_v37 -> T.TI32 _v37) $ Set.toList _v31))) $ baseMessage_sint record
  , (\_v31 -> P.Just (11, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v31))) $ baseMessage_status record
  ]
write_BaseMessage :: (T.Protocol p, T.Transport t) => p t -> BaseMessage -> P.IO ()
write_BaseMessage oprot record = T.writeVal oprot $ from_BaseMessage record
encode_BaseMessage :: (T.Protocol p, T.Transport t) => p t -> BaseMessage -> LBS.ByteString
encode_BaseMessage oprot record = T.serializeVal oprot $ from_BaseMessage record
to_BaseMessage :: T.ThriftVal -> BaseMessage
to_BaseMessage (T.TStruct fields) = BaseMessage{
  baseMessage_str = P.maybe (baseMessage_str default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TString _val40 -> E.decodeUtf8 _val40; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  baseMessage_flag = P.maybe (baseMessage_flag default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TBool _val41 -> _val41; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  baseMessage_b = P.maybe (baseMessage_b default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TByte _val42 -> _val42; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  baseMessage_int16 = P.maybe (baseMessage_int16 default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TI16 _val43 -> _val43; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  baseMessage_int32 = P.maybe (baseMessage_int32 default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TI32 _val44 -> _val44; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  baseMessage_int64 = P.maybe (baseMessage_int64 default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TI64 _val45 -> _val45; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  baseMessage_d = P.maybe (baseMessage_d default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TDouble _val46 -> _val46; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  baseMessage_strs = P.maybe (baseMessage_strs default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TList _ _val47 -> (Vector.fromList $ P.map (\_v48 -> (case _v48 of {T.TString _val49 -> E.decodeUtf8 _val49; _ -> P.error "wrong type"})) _val47); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  baseMessage_mstrs = P.maybe (baseMessage_mstrs default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TMap _ _ _val50 -> (Map.fromList $ P.map (\(_k52,_v51) -> ((case _k52 of {T.TString _val53 -> E.decodeUtf8 _val53; _ -> P.error "wrong type"}),(case _v51 of {T.TI32 _val54 -> _val54; _ -> P.error "wrong type"}))) _val50); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  baseMessage_sint = P.maybe (baseMessage_sint default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TSet _ _val55 -> (Set.fromList $ P.map (\_v56 -> (case _v56 of {T.TI32 _val57 -> _val57; _ -> P.error "wrong type"})) _val55); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  baseMessage_status = P.maybe (baseMessage_status default_BaseMessage) (\(_,_val39) -> (case _val39 of {T.TI32 _val58 -> P.toEnum $ P.fromIntegral _val58; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_BaseMessage _ = P.error "not a struct"
read_BaseMessage :: (T.Transport t, T.Protocol p) => p t -> P.IO BaseMessage
read_BaseMessage iprot = to_BaseMessage <$> T.readVal iprot (T.T_STRUCT typemap_BaseMessage)
decode_BaseMessage :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> BaseMessage
decode_BaseMessage iprot bs = to_BaseMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_BaseMessage) bs
typemap_BaseMessage :: T.TypeMap
typemap_BaseMessage = Map.fromList [(1,("str",T.T_STRING)),(2,("flag",T.T_BOOL)),(3,("b",T.T_BYTE)),(4,("int16",T.T_I16)),(5,("int32",T.T_I32)),(6,("int64",T.T_I64)),(7,("d",T.T_DOUBLE)),(8,("strs",(T.T_LIST T.T_STRING))),(9,("mstrs",(T.T_MAP T.T_STRING T.T_I32))),(10,("sint",(T.T_SET T.T_I32))),(11,("status",T.T_I32))]
default_BaseMessage :: BaseMessage
default_BaseMessage = BaseMessage{
  baseMessage_str = "",
  baseMessage_flag = P.False,
  baseMessage_b = 0,
  baseMessage_int16 = 0,
  baseMessage_int32 = 0,
  baseMessage_int64 = 0,
  baseMessage_d = 0,
  baseMessage_strs = Vector.empty,
  baseMessage_mstrs = Map.empty,
  baseMessage_sint = Set.empty,
  baseMessage_status = (P.toEnum 0)}
data Outer = Outer  { outer_outer_str :: LT.Text
  , outer_inner :: Inner
  , outer_outer_double :: P.Double
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Outer where
  hashWithSalt salt record = salt   `H.hashWithSalt` outer_outer_str record   `H.hashWithSalt` outer_inner record   `H.hashWithSalt` outer_outer_double record  
instance QC.Arbitrary Outer where 
  arbitrary = M.liftM Outer (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Outer = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Outer{outer_outer_str = outer_outer_str obj} then P.Nothing else P.Just $ default_Outer{outer_outer_str = outer_outer_str obj}
    , if obj == default_Outer{outer_inner = outer_inner obj} then P.Nothing else P.Just $ default_Outer{outer_inner = outer_inner obj}
    , if obj == default_Outer{outer_outer_double = outer_outer_double obj} then P.Nothing else P.Just $ default_Outer{outer_outer_double = outer_outer_double obj}
    ]
from_Outer :: Outer -> T.ThriftVal
from_Outer record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v61 -> P.Just (1, ("outer_str",T.TString $ E.encodeUtf8 _v61))) $ outer_outer_str record
  , (\_v61 -> P.Just (2, ("inner",from_Inner _v61))) $ outer_inner record
  , (\_v61 -> P.Just (7, ("outer_double",T.TDouble _v61))) $ outer_outer_double record
  ]
write_Outer :: (T.Protocol p, T.Transport t) => p t -> Outer -> P.IO ()
write_Outer oprot record = T.writeVal oprot $ from_Outer record
encode_Outer :: (T.Protocol p, T.Transport t) => p t -> Outer -> LBS.ByteString
encode_Outer oprot record = T.serializeVal oprot $ from_Outer record
to_Outer :: T.ThriftVal -> Outer
to_Outer (T.TStruct fields) = Outer{
  outer_outer_str = P.maybe (outer_outer_str default_Outer) (\(_,_val63) -> (case _val63 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  outer_inner = P.maybe (outer_inner default_Outer) (\(_,_val63) -> (case _val63 of {T.TStruct _val65 -> (to_Inner (T.TStruct _val65)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  outer_outer_double = P.maybe (outer_outer_double default_Outer) (\(_,_val63) -> (case _val63 of {T.TDouble _val66 -> _val66; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_Outer _ = P.error "not a struct"
read_Outer :: (T.Transport t, T.Protocol p) => p t -> P.IO Outer
read_Outer iprot = to_Outer <$> T.readVal iprot (T.T_STRUCT typemap_Outer)
decode_Outer :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Outer
decode_Outer iprot bs = to_Outer $ T.deserializeVal iprot (T.T_STRUCT typemap_Outer) bs
typemap_Outer :: T.TypeMap
typemap_Outer = Map.fromList [(1,("outer_str",T.T_STRING)),(2,("inner",(T.T_STRUCT typemap_Inner))),(7,("outer_double",T.T_DOUBLE))]
default_Outer :: Outer
default_Outer = Outer{
  outer_outer_str = "",
  outer_inner = default_Inner,
  outer_outer_double = 0}
data Inner = Inner  { inner_inner_str :: LT.Text
  , inner_inner_double :: P.Double
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable Inner where
  hashWithSalt salt record = salt   `H.hashWithSalt` inner_inner_str record   `H.hashWithSalt` inner_inner_double record  
instance QC.Arbitrary Inner where 
  arbitrary = M.liftM Inner (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Inner = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Inner{inner_inner_str = inner_inner_str obj} then P.Nothing else P.Just $ default_Inner{inner_inner_str = inner_inner_str obj}
    , if obj == default_Inner{inner_inner_double = inner_inner_double obj} then P.Nothing else P.Just $ default_Inner{inner_inner_double = inner_inner_double obj}
    ]
from_Inner :: Inner -> T.ThriftVal
from_Inner record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v69 -> P.Just (1, ("inner_str",T.TString $ E.encodeUtf8 _v69))) $ inner_inner_str record
  , (\_v69 -> P.Just (7, ("inner_double",T.TDouble _v69))) $ inner_inner_double record
  ]
write_Inner :: (T.Protocol p, T.Transport t) => p t -> Inner -> P.IO ()
write_Inner oprot record = T.writeVal oprot $ from_Inner record
encode_Inner :: (T.Protocol p, T.Transport t) => p t -> Inner -> LBS.ByteString
encode_Inner oprot record = T.serializeVal oprot $ from_Inner record
to_Inner :: T.ThriftVal -> Inner
to_Inner (T.TStruct fields) = Inner{
  inner_inner_str = P.maybe (inner_inner_str default_Inner) (\(_,_val71) -> (case _val71 of {T.TString _val72 -> E.decodeUtf8 _val72; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inner_inner_double = P.maybe (inner_inner_double default_Inner) (\(_,_val71) -> (case _val71 of {T.TDouble _val73 -> _val73; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_Inner _ = P.error "not a struct"
read_Inner :: (T.Transport t, T.Protocol p) => p t -> P.IO Inner
read_Inner iprot = to_Inner <$> T.readVal iprot (T.T_STRUCT typemap_Inner)
decode_Inner :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Inner
decode_Inner iprot bs = to_Inner $ T.deserializeVal iprot (T.T_STRUCT typemap_Inner) bs
typemap_Inner :: T.TypeMap
typemap_Inner = Map.fromList [(1,("inner_str",T.T_STRING)),(7,("inner_double",T.T_DOUBLE))]
default_Inner :: Inner
default_Inner = Inner{
  inner_inner_str = "",
  inner_inner_double = 0}
data DemoMessage = DemoMessage  { demoMessage_msg :: LT.Text
  , demoMessage_xx :: LT.Text
  } deriving (P.Show,P.Eq,TY.Typeable)
instance H.Hashable DemoMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` demoMessage_msg record   `H.hashWithSalt` demoMessage_xx record  
instance QC.Arbitrary DemoMessage where 
  arbitrary = M.liftM DemoMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DemoMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DemoMessage{demoMessage_msg = demoMessage_msg obj} then P.Nothing else P.Just $ default_DemoMessage{demoMessage_msg = demoMessage_msg obj}
    , if obj == default_DemoMessage{demoMessage_xx = demoMessage_xx obj} then P.Nothing else P.Just $ default_DemoMessage{demoMessage_xx = demoMessage_xx obj}
    ]
from_DemoMessage :: DemoMessage -> T.ThriftVal
from_DemoMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v76 -> P.Just (1, ("msg",T.TString $ E.encodeUtf8 _v76))) $ demoMessage_msg record
  , (\_v76 -> P.Just (2, ("xx",T.TString $ E.encodeUtf8 _v76))) $ demoMessage_xx record
  ]
write_DemoMessage :: (T.Protocol p, T.Transport t) => p t -> DemoMessage -> P.IO ()
write_DemoMessage oprot record = T.writeVal oprot $ from_DemoMessage record
encode_DemoMessage :: (T.Protocol p, T.Transport t) => p t -> DemoMessage -> LBS.ByteString
encode_DemoMessage oprot record = T.serializeVal oprot $ from_DemoMessage record
to_DemoMessage :: T.ThriftVal -> DemoMessage
to_DemoMessage (T.TStruct fields) = DemoMessage{
  demoMessage_msg = P.maybe (demoMessage_msg default_DemoMessage) (\(_,_val78) -> (case _val78 of {T.TString _val79 -> E.decodeUtf8 _val79; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  demoMessage_xx = P.maybe (demoMessage_xx default_DemoMessage) (\(_,_val78) -> (case _val78 of {T.TString _val80 -> E.decodeUtf8 _val80; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_DemoMessage _ = P.error "not a struct"
read_DemoMessage :: (T.Transport t, T.Protocol p) => p t -> P.IO DemoMessage
read_DemoMessage iprot = to_DemoMessage <$> T.readVal iprot (T.T_STRUCT typemap_DemoMessage)
decode_DemoMessage :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> DemoMessage
decode_DemoMessage iprot bs = to_DemoMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_DemoMessage) bs
typemap_DemoMessage :: T.TypeMap
typemap_DemoMessage = Map.fromList [(1,("msg",T.T_STRING)),(2,("xx",T.T_STRING))]
default_DemoMessage :: DemoMessage
default_DemoMessage = DemoMessage{
  demoMessage_msg = "",
  demoMessage_xx = ""}
